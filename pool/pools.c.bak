#define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <limits.h>
#include <unistd.h>
#include <signal.h>
#include <getopt.h>
#include <assert.h>
#include <err.h>
#include <semaphore.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/wait.h>

struct pool {
  const char *key;
  char *name;
  unsigned limit;
  sem_t *sem;
  struct pool *next;
};

static struct pool *pools = NULL;
static pid_t pid = -1;

static void forward_signal(int sig) {
  assert(pid >= 0);
  if (kill(pid, sig) < 0)
    err(EXIT_FAILURE, "kill");
}

// TODO: Share code with client's parse_pool.
static void parse_pool(char *s) {
  struct pool *pool;
  if ((pool = malloc(sizeof *pool)) == NULL)
    err(EXIT_FAILURE, "malloc");

  if ((pool->key = strsep(&s, "=")) == NULL)
    errx(EXIT_FAILURE, "pool specification missing value: %s", s);
  char *end;
  const unsigned long limit = strtoul(s, &end, 0);
  if (*s == '\0' || *end != '\0')
    errx(EXIT_FAILURE, "failed to parse pool limit: %s", s);
  if (limit > UINT_MAX)
    errx(EXIT_FAILURE, "pool limit doesn't fit in unsigned integer: %lu", limit);
  pool->limit = limit;

  // Create the semaphore.
  if (asprintf(&pool->name, "/pool.%s", pool->key) < 0)
    err(EXIT_FAILURE, "asprintf");
  if ((pool->sem = sem_open(pool->name, O_CREAT | O_EXCL, S_IRUSR | S_IWUSR, pool->limit)) == SEM_FAILED)
    err(EXIT_FAILURE, "sem_open: %s", pool->name);

  // Append the pool to the linked list.
  pool->next = pools;
  pools = pool;
}

static void usage(const char *prog, FILE *f) {
  fprintf(f, "usage: %s [-h|--help] [-p|--pool key=value]... [--] command [args...]\n", prog);
}

int main(int argc, char *argv[]) {
  const char *prog = argv[0];

  // Parse command-line options.
  // usage: makepool (-p|--pool key=value)+ command [args...]
  const struct option longopts[] = {
    {"help", no_argument, NULL, 'h'},
    {"pool", required_argument, NULL, 'p'},
    {NULL, 0, NULL, 0},
  };

  int optc;
  while ((optc = getopt_long(argc, argv, "hp:f:", longopts, NULL)) >= 0) {
    switch (optc) {
    case 'h':
      usage(prog, stdout);
      return EXIT_SUCCESS;

    case 'p':
      parse_pool(optarg);
      break;

    default:
      usage(prog, stderr);
      return EXIT_FAILURE;
    }
  }

  // Make sure we have a command.
  if (argc == optind) {
    usage(prog, stderr);
    return EXIT_FAILURE;
  }

  // Execute the program.
  pid = fork();
  if (pid < 0) {
    err(EXIT_FAILURE, "fork");
  } else if (pid == 0) {
    char **cmd = &argv[optind];
    execvp(cmd[0], cmd);
    err(EXIT_FAILURE, "execvp: %s", cmd[0]);
  }

  // Ignore SIGINT and SIGTERM for now.
  if (signal(SIGINT, forward_signal) < 0 ||
      signal(SIGTERM, forward_signal) < 0)
    err(EXIT_FAILURE, "signal");
  
  // Wait for child to finish.
  int status;
  if (wait(&status) < 0)
    err(EXIT_FAILURE, "wait");

  // Unlink the semaphores.
  // They'll be automatically closed.
  const struct pool *pool = pools;
  for (const struct pool *pool = pools; pool; pool = pool->next)
    sem_unlink(pool->name);

  // Exit with child's status.
  if (WIFEXITED(status)) {
    return WEXITSTATUS(status);
  } else if (WIFSIGNALED(status)) {
    errx(EXIT_FAILURE, "child terminated: %s", strsignal(WTERMSIG(status)));
  }

  // Unreachable.
  abort();
}
