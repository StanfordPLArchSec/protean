
static void parse_pool(char *s) {
  const char *key = strsep(&s, "=");
  if (!key)
    errx(EXIT_FAILURE, "bad pool specification: %s", s);

  // Parse the pool amount.
  char *end;
  const unsigned long amount = strtoul(s, &end, 0);
  if (*s == '\0' || *end != '\0')
    errx(EXIT_FAILURE, "failed to parse pool amount: %s", s);
  if (amount >= UINT_MAX)
    errx(EXIT_FAILURE, "pool amount doesn't fit in unsigned integer: %lu", amount);

  // Open the sempahore.
  char *name;
  if (asprintf(&name, "/pool.%s", key) < 0)
    err(EXIT_FAILURE, "asprintf");
  sem_t *sem;
  if ((sem = sem_open(name, 0)) == SEM_FAILED)
    err(EXIT_FAILURE, "sem_open: %s", name);

  sem_wait(sem)
}

int main(int argc, char *argv[]) {
  const char *prog = argv[0];

  // Parse command-line options.
  const struct option longopts[] = {
    {"help", no_argument, NULL, 'h'},
    {"pool", required_argument, NULL, 'p'},
    {NULL, 0, NULL, 0},
  };

  int optc;
  while ((optc = getopt_long(argc, argv, "hp:", longopts, NULL)) >= 0) {
    switch (optc) {
    case 'h':
      usage(prog, stdout);
      return EXIT_SUCCESS;

    case 'p':
      parse_pool(optarg);
      break;

    default:
      usage(prog, stderr);
      return EXIT_FAILURE;
    }
  }

  // Make sure we have a command.
  if (argc == optind) {
    usage(prog, stderr);
    return EXIT_FAILURE;
  }

  // Execute the program.
  pid = fork();

}
