/*
 * Copyright (C) 2004-2021 Intel Corporation.
 * SPDX-License-Identifier: MIT
 */

#include <iostream>
#include <fstream>
#include <set>
#include <cinttypes>
#include <unistd.h>
#include <filesystem>
#include <err.h>
#include <dirent.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <ctime>
#include <cstdio>
#include <vector>
#include <array>
#include <fcntl.h>
#include <syscall.h>
#include <sys/resource.h>
#include <asm/prctl.h>
#include "pin.H"
#include "MiscRegs.h"
using std::cerr;
using std::endl;
using std::ios;
using std::ofstream;
using std::string;

#if 0
static void dump_file(const char *path) {
  FILE *f;
  if ((f = fopen(path, "r")) == nullptr)
    err(EXIT_FAILURE, "fopen: %s", path);
  char line[1024];
  while (fgets(line, sizeof line, f))
    fprintf(stderr, "%s", line);
  fclose(f);
}
#endif

#if 0
static bool read_procfs(const char *path, std::vector<std::string>& lines) {
  char buf[256];
  sprintf(buf, "/proc/%d/%s", PIN_GetPid(), path);
  int fd;
  if ((fd = open(buf, O_RDONLY)) < 0)
    return nullptr;
  
}
#endif

static void create_directory(char *path) {
  DIR *d = opendir(path);
  if (d) {
    closedir(d);
  } else if (errno == ENOENT) {
    if (mkdir(path, 0775) < 0)
      err(EXIT_FAILURE, "mkdir: %s", path);
  } else {
    err(EXIT_FAILURE, "opendir: %s", path);
  }
}

static void create_directories(char *path) {
  char *it = path;
  if (*it == '/')
    ++it;
  while (true) {
    it = strchr(it, '/');
    if (it == nullptr)
      break;
    *it = '\0';
    create_directory(path);
    *it++ = '/';
  }
  create_directory(path);
}


static std::string output_dir;
static long long simpoint_tgt; // current target icount
static unsigned long long interval_size;
static unsigned long long warmup_size;
static uint64_t physmem_size;
static uintptr_t pagesize;
static unsigned long program_break;

struct Simpoint {
  unsigned id;
  unsigned long long interval;
  float weight;
  
  bool operator<(const Simpoint& o) const {
    assert(interval != o.interval);
    return interval < o.interval;
  }

  unsigned long long target() const {
    assert(interval_size > warmup_size);
    if (interval == 0) {
      return 0;
    } else {
      return interval * interval_size - warmup_size;
    }
  }
};

using Simpoints = std::set<Simpoint>;
static Simpoints simpoints;
static Simpoints::iterator simpoint_it;

static ofstream OutFile;

 
// The running count of instructions is kept here
// make it static to help the compiler optimize docount
static UINT64 icount = 0;


struct PhysPage {
  uintptr_t paddr;
  int prot;
  std::string name;
};

struct VmaEntry {
  uintptr_t vaddr_start;
  uintptr_t vaddr_stop;
  std::string name;

  size_t size() const {
    assert(vaddr_stop >= vaddr_start);
    return vaddr_stop - vaddr_start;
  }
};

static void dump_config(FILE *f, const std::map<uintptr_t, PhysPage>& virt2phys, const std::vector<VmaEntry>& vmalist, CONTEXT *ctx) {
  {
    time_t now;
    struct tm *timeinfo;
    if (time(&now) < 0)
      err(EXIT_FAILURE, "time");
    timeinfo = localtime(&now);
    fprintf(f, "## checkpoint generated by Checkpointer pintool: %s\n", asctime(timeinfo));
  }

  fprintf(f, R"#(
[system.membus]
currState=0
prvEvalTick=0

[system.membus.snoop_filter]

[system.membus.power_state]
currState=0
prvEvalTick=0

[system.mem_ctrls]
currState=0
prvEvalTick=0

[system.mem_ctrls.power_state]
currState=0
prvEvalTick=0

[system.dvfs_handler]
enableHandler=false
domain_ids=
perf_levels=
whens=
)#");

  const auto dump_buf = [&] (const std::vector<uint8_t>& buf) {
    for (uint8_t c : buf)
      fprintf(f, "%hhu ", c);
  };
  const auto dump_reg = [&] (REG reg) {
    std::vector<uint8_t> buf(REG_Size(reg));
    PIN_GetContextRegval(ctx, reg, buf.data());
    dump_buf(buf);
  };
  const auto dump_pad = [&] (unsigned pad) {
    std::vector<uint8_t> buf(pad, 0);
    dump_buf(buf);
  };
  const auto dump_u64 = [&] (uint64_t x) {
    std::vector<uint8_t> buf(sizeof x);
    std::memcpy(buf.data(), &x, buf.size());
    dump_buf(buf);
  };
  

  fprintf(f, "\n[system.cpu]\ninstCnt=%" PRIu64 "\n_pid=%d\n", icount, PIN_GetPid());

  fprintf(f, "\n[system.cpu.xc.0]\n");

  // src/arch/x86/regs/apic.hh
  fprintf(f, "regs=");
  dump_pad(70);
  fprintf(f, "\n");

  fprintf(f, R"=(
pendingSmi=false
smiVector=0
pendingNmi=false
nmiVector=0
pendingExtInt=false
extIntVector=0
pendingInit=false
initVector=0
pendingStartup=false
startupVector=0
startedUp=false
pendingUnmaskableInt=false
pendingIPIs=0
IRRV=0
ISRV=0
apicTimerEventScheduled=false
apicTimerEventTick=0
_status=0
)=");

  // REGISTER STATES
  
  // ARCHITECTURAL INTEGER REGISTERS
  fprintf(f, "regs.integer=");
  static const std::array<REG, 16> arch_int_regs = {
    REG_RAX, REG_RCX, REG_RDX, REG_RBX, REG_RSP, REG_RBP, REG_RSI, REG_RDI,
    REG_R8, REG_R9, REG_R10, REG_R11, REG_R12, REG_R13, REG_R14, REG_R15,
  };
  for (REG reg : arch_int_regs)
    dump_reg(reg);
  dump_pad(312 - 16 * 8);
  fprintf(f, "\n");

  // ARCHITECTURAL FLOATING POINT REGISTERS
  fprintf(f, "regs.floating_point=");
  dump_pad(8 * 8); // for FP/MMX registers
  for (REG xmm = REG_XMM0; xmm <= REG_XMM15; ++xmm)
    dump_reg(xmm);
  dump_pad(8 * 8);

  // ARCHITECTURAL VECTOR REGISTERS
  fprintf(f, R"=(
regs.vector=0 0 0 0 0 0 0 0
regs.vector_element=0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
regs.vector_predicate=0 0 0 0 0 0 0 0
regs.matrix=0 0 0 0 0 0 0 0
)=");

  // RFLAGS
  fprintf(f, "regs.condition_code=");
  const uint64_t rflags = PIN_GetContextReg(ctx, REG_RFLAGS);
  dump_u64(rflags & (1 << 2 | 1 << 4 | 1 << 6 | 1 << 7));
  dump_u64(rflags & (1 << 0 | 1 << 11));
  dump_u64(rflags & (1 << 10));
  dump_u64(0); // for the microarch flags
  dump_u64(0);
  fprintf(f, "\n");

  // PC, etc.
  fprintf(f, "_pc=%" PRIuPTR "\n", PIN_GetContextReg(ctx, REG_RIP));
  fprintf(f, "_upc=0\n");
  fprintf(f, "_npc=0\n"); // WARN: this might cause crash?
  fprintf(f, "_nupc=0\n"); // WARN: might be incorrect
  fprintf(f, "_size=0\n");
  
  
  ///----------- CPU WORKLOAD ---------///

  // parse /proc/pid/stat file
  {
    char stat_path[256];
    sprintf(stat_path, "/proc/%d/stat", PIN_GetPid());
    int stat_fd;
    if ((stat_fd = open(stat_path, O_RDONLY)) < 0)
      err(EXIT_FAILURE, "open: %s", stat_path);
    char stat_buf[4096];
    ssize_t stat_len;
    if ((stat_len = read(stat_fd, stat_buf, sizeof stat_buf - 1)) < 0)
      err(EXIT_FAILURE, "read");
    stat_buf[stat_len] = '\0';

    std::array<const char *, 52> stat_tokens;
    char *stat_tok = stat_buf;
    for (unsigned i = 0; i < stat_tokens.size(); ++i) {
      const char *token = strsep(&stat_tok, " ");
      if (!token || strlen(token) == 0)
	errx(EXIT_FAILURE, "error parsing %s", stat_path);
      stat_tokens[i] = token;
    }

    unsigned long start_brk;
    if (sscanf(stat_tokens[47], "%lu", &start_brk) != 1)
      errx(EXIT_FAILURE, "error parsing statrt_brk in %s", stat_path);
    if (program_break > 0)
      start_brk = program_break;

#if 0
    unsigned long startstack;
    if (sscanf(stat_tokens[28], "%lu", &startstack) != 1)
      errx(EXIT_FAILURE, "error parsing startstack in %s", stat_path);
#else
    const auto vma_it = std::find_if(vmalist.begin(), vmalist.end(), [] (const VmaEntry& vma) -> bool {
      return vma.name == "[stack]";
    });
    if (vma_it == vmalist.end())
      errx(EXIT_FAILURE, "failed to find [stack] vma entry in /proc/pid/maps");
    const unsigned long stackMin = vma_it->vaddr_start;
    const unsigned long stackSize = vma_it->size();
    const unsigned long stackBase = vma_it->vaddr_stop;
#endif
#if 0
    struct rlimit maxStackSize;
    if (prlimit(PIN_GetPid(), RLIMIT_STACK, nullptr, &maxStackSize) < 0)
      err(EXIT_FAILURE, "prlimit");
#else
    unsigned long maxStackSize;
    {
      char limits_path[256];
      sprintf(limits_path, "/proc/%d/limits", PIN_GetPid());
      int limits_fd;
      if ((limits_fd = open(limits_path, O_RDONLY)) < 0)
	err(EXIT_FAILURE, "open: %s", limits_path);
      char limits_buf[4096];
      ssize_t limits_len;
      if ((limits_len = read(limits_fd, limits_buf, sizeof limits_buf - 1)) < 0)
	err(EXIT_FAILURE, "read: %s", limits_path);
      limits_buf[limits_len] = '\0';
      char *max_stack_size_s;
      if ((max_stack_size_s = strstr(limits_buf, "Max stack size")) == nullptr)
	errx(EXIT_FAILURE, "failed to find 'Max stack size' in limits");
      if (sscanf(max_stack_size_s, "Max stack size %lu", &maxStackSize) != 1)
	errx(EXIT_FAILURE, "failed to parse 'Max stack size'");
    }
#endif
  
  // This section is totally bullshitted. We might need to more intelligently handle this.
    fprintf(f, "\n[system.cpu.workload]\n"); 
    fprintf(f, "brkPoint=%lu\n", start_brk);
    fprintf(f, "stackBase=%lu\n", stackBase);
    fprintf(f, "stackSize=%lu\n", stackSize);
    fprintf(f, "maxStackSize=%" PRIu64 "\n", maxStackSize); // WARN
    fprintf(f, "stackMin=%lu\n", stackMin); // WARN
    fprintf(f, "nextThreadStackBase=0\n"); // WARN
    fprintf(f, "mmapEnd=%" PRIu64 "\n", 0x7FFFF7FFF000); // WARN
  }
  
  // vmalist???
  // WARN: skipping VMALIST for now
  fprintf(f, "\n[system.cpu.workload.vmalist]\n");
  fprintf(f, "size=%zu\n", vmalist.size());
  for (size_t i = 0; i < vmalist.size(); ++i) {
    const VmaEntry& vma = vmalist[i];
    fprintf(f, "\n[system.cpu.workload.vmalist.Vma%zu]\n", i);
    fprintf(f, "name=%s\n", vma.name.empty() ? "anon" : vma.name.c_str());
    fprintf(f, "addrRangeStart=%" PRIuPTR "\n", vma.vaddr_start);
    fprintf(f, "addrRangeEnd=%" PRIuPTR "\n", vma.vaddr_stop);
  }

  // system.cpu.workload.ptable
  fprintf(f, "\n[system.cpu.workload.ptable]\n");
  fprintf(f, "size=%zu\n", virt2phys.size());

  size_t vaddr_idx = 0;
  for (const auto& [vaddr, page] : virt2phys) {
    const auto& [paddr, prot, name] = page;
    fprintf(f, "\n[system.cpu.workload.ptable.Entry%zu]\n", vaddr_idx++);
    fprintf(f, "vaddr=%" PRIuPTR "\n", vaddr);
    fprintf(f, "paddr=%" PRIuPTR "\n", paddr);
    fprintf(f, "flags=0\n"); // WARN
  }


  // system.cpu.workload.fdarray
  fprintf(f, "\n[system.cpu.workload.fdarray]\n");
  fprintf(f, "size=1024\n");
  for (unsigned i = 0; i < 1024; ++i) {
    fprintf(f, "\n[system.cpu.workload.fdarray.Entry%u]\n", i);

    char fd_path[256];
    sprintf(fd_path, "/proc/%d/fd/%u", PIN_GetPid(), i);

    // check if the fd exists
    if (access(fd_path, F_OK) < 0) {
      if (errno != ENOENT) {
	err(EXIT_FAILURE, "access: %s", fd_path);
      }
      fprintf(f, "class=6\n");
      continue;
    }

    // now we know that the fd exists; check if a path
    char link[1024];
    ssize_t link_len;
    if ((link_len = readlink(fd_path, link, sizeof link - 1)) < 0) {
      if (errno == EINVAL) {
	// not a symbolic link
	errx(EXIT_FAILURE, "not a symoblic link");
      }
      err(EXIT_FAILURE, "readlink");
    }
    assert(static_cast<size_t>(link_len) < sizeof link);
    link[link_len] = '\0';
    if (link[0] != '/') {
      errx(EXIT_FAILURE, "unhandled link: %s", link);
    }

    // filter out 'bad' paths
    if (strncmp(link, "/proc/", strlen("/proc/")) == 0) {
      // pretend like it doesn't exist
      fprintf(f, "class=6\n");
      continue;
    }

    // file fd
    char info_path[256];
    sprintf(info_path, "/proc/%d/fdinfo/%u", PIN_GetPid(), i);
    int info_fd;
    if ((info_fd = open(info_path, O_RDONLY)) < 0)
      err(EXIT_FAILURE, "open: %s", info_path);
    char info_buf[4096];
    memset(info_buf, 0, sizeof info_buf);
    if (read(info_fd, info_buf, sizeof info_buf) < 0)
      err(EXIT_FAILURE, "read");
    close(info_fd);
#if 0
    uint64_t pos;
    if (fscanf(f, "pos: %" SCNu64 "\n", &pos) != 1) {
      dump_file(info_path);
      errx(EXIT_FAILURE, "error parsing 'pos' from %s", info_path);

    }
    uint32_t flags;
    if (fscanf(f, "flags: %" SCNo32 "\n", &flags) != 1)
      errx(EXIT_FAILURE, "error paring 'flags' from %s", info_path);
#else
    uint64_t pos;
    uint32_t flags;
    const char *pos_s = strstr(info_buf, "pos:");
    const char *flags_s = strstr(info_buf, "flags:");
    fprintf(stderr, "%s\n", info_buf);
    assert(pos_s && flags_s);
    if (sscanf(pos_s, "pos: %" SCNu64 "\n", &pos) != 1)
      errx(EXIT_FAILURE, "errorp arsing 'pos' from %s", info_path);
    if (sscanf(flags_s, "flags: %" SCNo32 "\n", &flags) != 1)
      errx(EXIT_FAILURE, "error paring 'flags' from %s", info_path);
#endif
    fprintf(f, "class=2\n");
    fprintf(f, "_closeOnExec=false\n"); // WARN
    fprintf(f, "_flags=%" PRIu32 "\n", flags);
    fprintf(f, "_fileName=%s\n", link);
    fprintf(f, "_fileOffset=%" PRIu64 "\n", pos);
    fprintf(f, "_mode=0\n"); // WARN
  }

  fprintf(f, R"=(
[system.cpu.tracer]

[system.cpu.power_state]
currState=1
prvEvalTick=0

[system.cpu.mmu]

[system.cpu.mmu.itb]
_size=0
lruSeq=0
)=");

#if 0
  // dummy itb entries
  for (unsigned i = 0; i < 64; ++i) {
    fprintf(f, "\n[system.cpu.mmu.itb.Entry%u]\n", i);
    fprintf(f, "paddr=0\n");
    fprintf(f, "vaddr=0\n");
    fprintf(f, "logBytes=12\n");
    fprintf(f, "writable=true\n");
    fprintf(f, "user=true\n");
    fprintf(f, "uncacheable=false\n");
    fprintf(f, "global=false\n");
    fprintf(f, "patBit=false\n");
    fprintf(f, "noExec=false\n");
    fprintf(f, "lruSeq=0\n");
  }
#endif

  fprintf(f, R"=(
[system.cpu.mmu.itb.walker]
currState=0
prvEvalTick=0

[system.cpu.mmu.itb.walker.power_state]
currState=0
prvEvalTick=0
  )=");

  fprintf(f, R"=(
[system.cpu.mmu.dtb]
_size=0
lruSeq=0
)=");

#if 0
  // dummy dtb entries
  for (unsigned i = 0; i < 64; ++i) {
    fprintf(f, "\n[system.cpu.mmu.dtb.Entry%u]\n", i);
    fprintf(f, "paddr=0\n");
    fprintf(f, "vaddr=0\n");
    fprintf(f, "logBytes=12\n");
    fprintf(f, "writable=true\n");
    fprintf(f, "user=true\n");
    fprintf(f, "uncacheable=false\n");
    fprintf(f, "global=false\n");
    fprintf(f, "patBit=false\n");
    fprintf(f, "noExec=false\n");
    fprintf(f, "lruSeq=0\n");
  }
#endif

  fprintf(f, R"=(
[system.cpu.mmu.dtb.walker]
currState=0
prvEvalTick=0

[system.cpu.mmu.dtb.walker.power_state]
currState=0
prvEvalTick=0

)=");



  

  fprintf(f, "\n[system.cpu.interrupts]\n");
  fprintf(f, "regs="); dump_pad(70); fprintf(f, "\n");
  fprintf(f, R"=(
pendingSmi=false
smiVector=0
pendingNmi=false
nmiVector=0
pendingExtInt=false
extIntVector=0
pendingInit=false
initVector=0
pendingStartup=false
startupVector=0
startedUp=false
pendingUnmaskableInt=false
pendingIPIs=0
IRRV=0
ISRV=0
apicTimerEventScheduled=false
apicTimerEventTick=0

[system.cpu.interrupts.clk_domain]

[system.cpu.decoder]

)=");

  /*
     Cr0 <= idx
     idx != Cr1
     idx != Cr5-7
     idx != Cr9-15
   */
  fprintf(f, "[system.cpu.isa]\n");
  fprintf(f, "regVal=");

  std::vector<uint64_t> misc(MiscReg::NumMiscRegs, 0);
  assert(misc.size() == 204);

  using MR = MiscReg::MiscReg;
  std::vector<std::pair<REG, MR>> misc_regs_to_set = {
    {REG_CR0, MR::Cr0},
    {REG_CR2, MR::Cr2},
    {REG_CR3, MR::Cr3},
    {REG_CR4, MR::Cr4},
    // {REG_CR8, MR::Cr8},
    {REG_DR0, MR::Dr0},
    {REG_DR1, MR::Dr1},
    {REG_DR2, MR::Dr2},
    {REG_DR3, MR::Dr3},
    {REG_DR4, MR::Dr4},
    {REG_DR5, MR::Dr5},
    {REG_DR6, MR::Dr6},
    {REG_DR7, MR::Dr7},
    {REG_RFLAGS, MR::Rflags},
    {REG_SEG_ES, MR::Es},
    {REG_SEG_CS, MR::Cs},
    {REG_SEG_SS, MR::Ss},
    {REG_SEG_DS, MR::Ds},
    {REG_SEG_FS, MR::Fs},
    {REG_SEG_GS, MR::Gs},
    {REG_SEG_FS_BASE, MR::FsBase},
    {REG_SEG_GS_BASE, MR::GsBase},
    {REG_SEG_FS_BASE, MR::FsEffBase},
    {REG_SEG_GS_BASE, MR::GsEffBase},
    {REG_MXCSR, MR::Mxcsr},
  };

  for (const auto& [r, mr] : misc_regs_to_set) {
    assert(REG_Size(r) <= sizeof(uint64_t));
    misc[mr] = PIN_GetContextReg(ctx, r);
  }
  
  
  misc[MR::Efer] = 0x4d01;
  misc[MR::EsAttr] = 0xb3db;
  misc[MR::CsAttr] = 0xaad3;
  misc[MR::SsAttr]=  0xb3db; // FIXED
  misc[MR::DsAttr]=  0xb3db; // FIXED
  misc[MR::FsAttr]=  0xb3db; // FIXED
  misc[MR::GsAttr]=  0xb3db; // FIXED
  misc[MR::HsAttr]=  0xb3db; // FIXED
  misc[MR::TslAttr]= 0xb3db; // FIXED
  misc[MR::TsgAttr]= 0xb3db; // FIXED
  misc[MR::LsAttr]=  0xb3db; // FIXED
  misc[MR::MsAttr]=  0xb3db; // FIXED
  misc[MR::TrAttr]=  0xb3db; // FIXED
  misc[MR::IdtrAttr]=0xb3db; // FIXED
  misc[MR::M5Reg] = 0x3b6f0;

  misc[MR::M5Reg] = 0x3b6f0;
  misc[MR::Mtrrcap] = 0x508;
  misc[MR::McgCap] = 0x104; // OMIT
  misc[MR::Pat] = 0x7040600070406;
  misc[MR::Efer] = 0x4d01; // FIXED
  misc[MR::Syscfg] = 0x20601; // OMIT
  misc[MR::TopMem] = 0x4000000;

  misc[MR::Cr0] = 0x80000033;
  misc[MR::Cr3] = 0x64;
  misc[MR::Cr4] = 0x20000;

  {
    unsigned long fs, gs;
    if (syscall(SYS_arch_prctl, ARCH_GET_FS, &fs) < 0 ||
	syscall(SYS_arch_prctl, ARCH_GET_GS, &gs) < 0)
      err(EXIT_FAILURE, "syscall");
    misc[MR::Fs] = misc[MR::FsBase] = misc[MR::FsEffBase] = fs;
    misc[MR::Gs] = misc[MR::GsBase] = misc[MR::GsEffBase] = gs;
  }

  for (uint64_t value : misc)
    fprintf(f, "%" PRIu64 " ", value);
  fprintf(f, "\n");

  fprintf(f, R"=(
[system.cpu_clk_domain]
_perfLevel=0

[system.cpu_voltage_domain]
_perfLevel=0

[system]
quiesceEndTick_0=0

[system.physmem]
lal_addr=
lal_cid=
nbr_of_stores=1
)=");

  fprintf(f, "\n[system.physmem.store0]\n");
  fprintf(f, "store_id=0\n");
  fprintf(f, "filename=system.physmem.store0.pmem\n");
  fprintf(f, "range_size=8589934592\n"); // FIXME: use mem_size.

  fprintf(f, R"=(
[system.workload]

[system.workload.mempools]
num_pools=1

[system.workload.mempools.pool0]
page_shift=12
start_page=0
free_page_num=3890
total_pages=2097152

[system.redirect_paths2]

[system.redirect_paths1]

[system.redirect_paths0]

[system.mem_ctrls.dram]
currState=0
prvEvalTick=0
)=");

  fprintf(f, R"=(
[system.clk_domain]
_perfLevel=0

[system.voltage_domain]
_perfLevel=0

[root]
FullSystem=false

[root.globals]
curTick=231808419000
version_tags=arm-ccregs arm-contextidr-el2 arm-gem5-gic-ext arm-gicv2-banked-regs arm-hdlcd-upgrade arm-miscreg-teehbr arm-sve arm-sysreg-mapping-ns armv8 cpu-pid dvfs-perflevel etherswitch globals-to-root ide-dma-abort isa-is-simobject memory-per-range mempool-sections mempool-to-seworkload multiple-event-queues process-fdmap-rename register-files remove-arm-cpsr-mode-miscreg ruby-block-size-bytes smt-interrupts x86-add-tlb
)=");

  fclose(f);
}



static void checkpoint(CONTEXT *ctx) {
  const int pid = PIN_GetPid();
  
  assert(simpoint_tgt >= 0 && simpoint_it != simpoints.end());

  const Simpoint& simpoint = *simpoint_it;  

  std::cerr << "Checkpoint " << simpoint.id << "\n";

  // Dump memory and create mappings.
  
  std::map<uintptr_t, PhysPage> virt2phys;
  std::vector<VmaEntry> vmalist;
  uintptr_t phys_nextpage = 0; 
  
  std::string maps_line;
  char maps_path[256];
  sprintf(maps_path, "/proc/%d/maps", pid);
  std::ifstream maps_file(maps_path);
  while (std::getline(maps_file, maps_line)) {
    /*
              The format of the file is:
                  address           perms offset  dev   inode       pathname
                  00400000-00452000 r-xp 00000000 08:02 173521      /usr/bin/dbus-daemon
     */
    uintptr_t range_begin, range_end;
    char prot_s[5];
    char name[256];
    name[0] = '\0';
    if (sscanf(maps_line.c_str(), "%" SCNxPTR "-%" SCNxPTR " %s %*s %*s %*s %s",
	       &range_begin, &range_end, prot_s, name) < 3) {
      std::cerr << "invalid /proc/pid/maps format, exiting\n";
      std::exit(EXIT_FAILURE);
    }

    {
      VmaEntry vma;
      vma.vaddr_start = range_begin;
      vma.vaddr_stop = range_end;
      vma.name = name;
      vmalist.push_back(std::move(vma));
    }

    assert(range_begin % pagesize == 0 && range_end % pagesize == 0 && range_begin < range_end);
    
    // Check protections
    int prot = 0;
    if (prot_s[0] == 'r')
      prot |= PROT_READ;
    if (prot_s[1] == 'w')
      prot |= PROT_WRITE;
    if (prot_s[2] == 'x')
      prot |= PROT_EXEC;

#if 0
    VmaEntry vma;
    vma.vaddr_start = range_begin;
    vma.vaddr_stop = range_end;
#endif

    for (size_t range_it = range_begin; range_it != range_end; range_it += pagesize, phys_nextpage += pagesize) {
      PhysPage& page = virt2phys[range_it];
      page.paddr = phys_nextpage;
      page.prot = prot;
      page.name = name;
    }
  }

  // Create checkpoint directory.
  char cpt_subdir[256];
  sprintf(cpt_subdir, "%s/cpt.simpoint_%02d_inst_%" PRIu64 "_weight_%.6f_interval_%llu_warmup_%llu",
	  output_dir.c_str(), simpoint.id, icount, simpoint.weight, interval_size, warmup_size);
  create_directories(cpt_subdir);
  

  // Memory dump.
  char memdump_path[512];
  sprintf(memdump_path, "%s/system.physmem.store0.pmem", cpt_subdir);
  char memdump_cmd[1024];
  sprintf(memdump_cmd, "gzip > %s", memdump_path);
  FILE *memdump_file;
  if ((memdump_file = popen(memdump_cmd, "w")) == nullptr) {
    err(EXIT_FAILURE, "popen: %s", memdump_cmd);
  }


  std::vector<char> data(pagesize);
  int i = 0;
  for (auto it = virt2phys.begin(); it != virt2phys.end(); ++it) {
    std::cerr << "\r" << i++ << "/" << virt2phys.size();
    
    const auto& [vaddr, page] = *it;

    if ((page.prot & PROT_READ) && PIN_SafeCopy(data.data(), (const VOID *) vaddr, pagesize) == pagesize) {
      // Got valid data, so write to file
    } else {
      // Didn't get valid data, so just write zeroes
      std::memset(data.data(), 0, data.size());
    }
    if (fwrite(data.data(), 1, data.size(), memdump_file) != data.size())
      err(EXIT_FAILURE, "fwrite");
  }
  std::cerr << "\n";

  std::memset(data.data(), 0, data.size());
  for (uintptr_t paddr = phys_nextpage; paddr < physmem_size; paddr += pagesize) {
    if (fwrite(data.data(), 1, data.size(), memdump_file) != data.size())
      err(EXIT_FAILURE, "fwrite");
  }

  pclose(memdump_file);


  // Print out m5.cpt
  char toml_path[512];
  sprintf(toml_path, "%s/m5.cpt", cpt_subdir);
  FILE *config;
  if ((config = fopen(toml_path, "w")) == nullptr)
    err(EXIT_FAILURE, "fopen: %s", toml_path);
  dump_config(config, virt2phys, vmalist, ctx);
  
  // Advance
  ++simpoint_it;
  if (simpoint_it == simpoints.end()) {
    simpoint_tgt = -1;
  } else {
    simpoint_tgt = simpoint_it->target();
  }
}
 
// This function is called before every block
VOID docount(UINT32 c, CONTEXT *ctx) {
  if (simpoint_tgt >= 0 && icount <= static_cast<uint64_t>(simpoint_tgt) &&
      icount + c > static_cast<uint64_t>(simpoint_tgt)) {
    // Checkpoint
    checkpoint(ctx);
  }
  
  icount += c;

#if 0
  if (icount == 10000) {
    // print proc maps
    char buf[256];
    sprintf(buf, "/proc/%d/maps", PIN_GetPid());
    FILE *maps;
    if ((maps = fopen(buf, "r")) == NULL) {
      perror("fopen");
      exit(1);
    }
    char line[1024];
    while (fgets(line, sizeof line, maps)) {
      fprintf(stderr, "%s", line);
    }
    fclose(maps);
  }
#endif
}

static ADDRINT sysno;

static void handle_syscall_entry(THREADID tid, CONTEXT *ctx, SYSCALL_STANDARD sys_std, VOID *null) {
  if (sys_std != SYSCALL_STANDARD_IA32E_LINUX)
    errx(EXIT_FAILURE, "unrecognized syscall standard: %d", sys_std);
  sysno = PIN_GetSyscallNumber(ctx, sys_std);
}

static void handle_syscall_exit(THREADID tid, CONTEXT *ctx, SYSCALL_STANDARD sys_std, VOID *null) {
  if (sys_std != SYSCALL_STANDARD_IA32E_LINUX)
    errx(EXIT_FAILURE, "unrecognized syscall standard: %d", sys_std);
  switch (sysno) {
  case SYS_brk:
    program_break = PIN_GetSyscallReturn(ctx, sys_std);
    break;
    
  default:
    return;
  }
}

 
// Pin calls this function every time a new basic block is encountered
// It inserts a call to docount
VOID Trace(TRACE trace, VOID* v)
{
    // Visit every basic block  in the trace
    for (BBL bbl = TRACE_BblHead(trace); BBL_Valid(bbl); bbl = BBL_Next(bbl))
    {
        // Insert a call to docount before every bbl, passing the number of instructions
      BBL_InsertCall(bbl, IPOINT_BEFORE, (AFUNPTR)docount, IARG_UINT32, BBL_NumIns(bbl), IARG_CONTEXT, IARG_END);
    }
}

KNOB< uint32_t > KnobEnable(KNOB_MODE_WRITEONCE, "pintool", "enable", "0", "enable");
KNOB< string > KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool", "o", "inscount.out", "specify output file name");
KNOB< string > KnobSimpointFile(KNOB_MODE_WRITEONCE, "pintool", "s", "simpoints.out", "specify input simpoint file name");
KNOB< string > KnobWeightFile(KNOB_MODE_WRITEONCE, "pintool", "w", "weights.out", "specify input weight file name");
KNOB< uint32_t > KnobInterval(KNOB_MODE_WRITEONCE, "pintool", "I", "10000000", "specify interval size");
KNOB< uint32_t > KnobWarmup(KNOB_MODE_WRITEONCE, "pintool", "W", "10000", "specify warmup size");
KNOB< string > KnobOutputDir(KNOB_MODE_WRITEONCE, "pintool", "O", "cpt", "specify output checkpoint directory");
KNOB< uint64_t > KnobPhysMemSize(KNOB_MODE_WRITEONCE, "pintool", "z", std::to_string(8 * 1024 * 1024), "specify physmem size in bytes");
 
// This function is called when the application exits
VOID Fini(INT32 code, VOID* v)
{
    // Write to a file since cout and cerr maybe closed by the application
    OutFile.setf(ios::showbase);
    OutFile << "Count " << icount << endl;
    OutFile.close();


    if (simpoint_it != simpoints.end()) {
      std::cerr << "Final count: " << icount << "\n";
      std::cerr << "Missed checkpoints:\n";
      for (; simpoint_it != simpoints.end(); ++simpoint_it) {
	std::cerr << "Checkpoint " << simpoint_it->id << " (" << simpoint_it->target() << ")\n";
      }
      exit(EXIT_FAILURE);
    }
}
 
/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */
 
INT32 Usage()
{
    cerr << "This tool counts the number of dynamic instructions executed" << endl;
    cerr << endl << KNOB_BASE::StringKnobSummary() << endl;
    return -1;
}
 
/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */


template <class Value> 
static std::map<unsigned, Value> parse_simpoint_file(const std::string& path) {
  std::map<unsigned, Value> map;
  std::ifstream f(path);
  std::string line;
  while (std::getline(f, line)) {
    std::stringstream ss(line);
    unsigned id;
    Value val;
    ss >> val >> id;
    if (!ss) {
      std::cerr << "invalid file format: " << path << "\n";
      std::exit(EXIT_FAILURE);
    }
    if (!map.emplace(id, val).second) {
      std::cerr << "duplicate entry in " << path << "\n";
      std::exit(EXIT_FAILURE);
    }
  }
  return map;
}

static BOOL FollowChild(CHILD_PROCESS cProcess, VOID *userData) {
  char **orig_args = (char **) userData;
  std::vector<const char *> args;
  for (char **it = orig_args; *it; ++it) {
    args.push_back(*it);
  }
  auto it = std::find_if(args.begin(), args.end(), [] (const char *s) {
    return strcmp(s, "-t") == 0;
  });
  assert(it != args.end());
  std::advance(it, 2);
  it = args.insert(it, "-enable");
  ++it;
  args.insert(it, "1");
  args.push_back(nullptr);
  CHILD_PROCESS_SetPinCommandLine(cProcess, args.size() - 1, args.data());
  return TRUE;
}
 
int main(int argc, char* argv[]) {
    // Initialize pin
    if (PIN_Init(argc, argv)) return Usage();

    if (!KnobEnable.Value()) {
      PIN_AddFollowChildProcessFunction(FollowChild, &argv[0]);
      PIN_StartProgram();
      return EXIT_SUCCESS;
    }
 
    OutFile.open(KnobOutputFile.Value().c_str());

    interval_size = KnobInterval.Value();
    warmup_size = KnobWarmup.Value();
    output_dir = KnobOutputDir.Value();
    physmem_size = KnobPhysMemSize.Value();
    pagesize = getpagesize();
    
    if ((physmem_size % pagesize) != 0)
      errx(EXIT_FAILURE, "physmem not a multiple of pagesize %" PRIxPTR "\n", pagesize);
    
    {
      const auto intervals = parse_simpoint_file<uint32_t>(KnobSimpointFile.Value());
      const auto weights = parse_simpoint_file<float>(KnobWeightFile.Value());
      if (intervals.size() != weights.size()) {
	std::cerr << "got " << intervals.size() << " but " << weights.size() << " weights\n";
	return EXIT_FAILURE;
      }

      auto interval_it = intervals.begin();
      auto weight_it = weights.begin();
      for (; interval_it != intervals.end(); ++interval_it, ++weight_it) {
	assert(weight_it != weights.end());
	if (interval_it->first != weight_it->first) {
	  std::cerr << "intervals and weights ids disagree\n";
	  return EXIT_FAILURE;
	}
	const Simpoint simpoint = {
	  .id = interval_it->first,
	  .interval = interval_it->second,
	  .weight = weight_it->second
	};
	simpoints.insert(simpoint);
      }

      if (simpoints.empty()) {
	std::cerr << "Found no simpoints!\n";
	return EXIT_FAILURE;
      }

      simpoint_it = simpoints.begin();
      simpoint_tgt = simpoint_it->target();
    }
 
    // Register Instruction to be called to instrument instructions
    TRACE_AddInstrumentFunction(Trace, 0);

    PIN_AddSyscallEntryFunction(&handle_syscall_entry, nullptr);
    PIN_AddSyscallExitFunction(&handle_syscall_exit, nullptr);
 
    // Register Fini to be called when the application exits
    PIN_AddFiniFunction(Fini, 0);
 
    // Start the program, never returns
    PIN_StartProgram();
 
    return 0;
}
